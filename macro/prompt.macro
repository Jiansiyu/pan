// -*- c++ -*-

//**********************************************************************
//
//     HALL A C++/ROOT Parity Analyzer  Pan           
//
//           prompt.macro
//
// Author:  R. Holmes <http://mep1.phy.syr.edu/~rsholmes>, A. Vacheret <http://www.jlab.org/~vacheret>, R. Michaels <http://www.jlab.org/~rom>, K.Paschke
// @(#)pan/src:$Name$:$Id$
//
////////////////////////////////////////////////////////////////////////
//
//  Prompt analysis macro
//
//  Produces plots of monitor differences, monitor double differences,
//  raw detector asymmetries, and corrected detector asymmetries.
//
//  Outputs a text file with means, errors, and widths of the above.
//
//  Most of this is a class definition.  At the end is a short macro 
//  to invoke the class and produce the plots and output.
//
////////////////////////////////////////////////////////////////////////

#include "TStyle.h"
#include <iostream>
#include <iomanip>
#include <stdlib.h>
#include <cmath>

void prompt (Int_t run);
void style ();

class Prompt
{
public:
  Prompt (Int_t run);
  void ~Prompt ();

  void Monitors ();
  void Detectors (UInt_t corrected);
  void Print ();

private:
  Int_t fRun;               // run number
  Int_t fNMon;              // number of beam monitors
  Int_t fNDif;              // number of differences to compute/display
  Int_t fNDDif;             // number of double differences to compute/display
  Int_t fNDetAsy;           // number of detector asyms to compute/display
  Int_t fNMod;              // number of modulation objects
  Int_t fNDimRegCor;        // number of monitors to use in regression corrections
  Int_t fNDimModCor;        // number of monitors and mod objects to use in modulation corrections
  Double_t*  fDifM;         // mean (monitor) differences
  Double_t*  fDifME;        // errors on mean differences
  Double_t*  fDifW;         // RMS widths of differences
  Double_t*  fDDifW;        // RMS widths of double differences
  Double_t*  fAsyM;         // mean (detector) asymmetries
  Double_t*  fAsyME;        // errors on mean asymmetries
  Double_t*  fAsyW;         // RMS widths of asymmetries
  Double_t*  fRCAsyM;       // mean (detector) regression corrected asymmetries
  Double_t*  fRCAsyME;      // errors on mean regression corrected asymmetries
  Double_t*  fRCAsyW;       // RMS widths of regression corrected asymmetries
  Double_t*  fMCAsyM;       // mean (detector) modulation corrected asymmetries
  Double_t*  fMCAsyME;      // errors on mean modulation corrected asymmetries
  Double_t*  fMCAsyW;       // RMS widths of modulation corrected asymmetries
  Double_t** fMonSlope;     // Monitor slopes
  Double_t** fDetSlope;     // Detector slopes
  Double_t** fDetRCoef;     // Detector regression coefficients
  Double_t** fDetRCoefE;    // Detector regression coefficient errors
  Double_t** fDetMCoef;     // Detector modulation coefficients
  Double_t** fDetMCoefE;    // Detector modulation coefficient errors
  TString* fMonTag;         // tag for monitor
  TString* fModTag;         // tag for modulation object
  Int_t*   fMonType;        // type of monitor: 0 = BCM, 1 = BPM
  Int_t*   fDifMon;         // list of monitor indices for differences
  Int_t*   fDDifMon0;       // list of monitor indices for double differences
  Int_t*   fDDifMon1;       // list of monitor indices for double differences
  Int_t*   fRegCorMon;      // list of monitors for modulation corrections
  Int_t*   fModCorMon;      // list of monitors for modulation corrections
  Int_t*   fModCorMod;      // list of modulation objects for corrections
  TString* fDifExp;         // TTree::Draw expression for monitor differences
  TString* fDDifExp;        // TTree::Draw expression for double differences
  TString* fAsyTag;         // tag for detector combination
  TString* fAsyExp;         // TTree::Draw expression for detector asymmetries
  TString* fRegCorExp;      // TTree::Draw expression for modulation corrected detector asymmetries
  TString* fModCorExp;      // TTree::Draw expression for modulation corrected detector asymmetries
};


TString
Prompt::Prompt (Int_t run): fRun(run)
{
  fNMon     = 8;
  fNDif     = 8;
  fNDDif    = 4;
  //  fNDetAsy  = 10;
  fNDetAsy  = 6;
  fNMod     = 8;
  fNDimRegCor  = 5;
  fNDimModCor  = 5;
  fDifM     = new Double_t[fNDif];
  fDifME    = new Double_t[fNDif];
  fDifW     = new Double_t[fNDif];
  fDDifW    = new Double_t[fNDDif];
  fAsyM     = new Double_t[fNDetAsy];
  fAsyME    = new Double_t[fNDetAsy];
  fAsyW     = new Double_t[fNDetAsy];
  fRCAsyM    = new Double_t[fNDetAsy];
  fRCAsyME   = new Double_t[fNDetAsy];
  fRCAsyW    = new Double_t[fNDetAsy];
  fMCAsyM    = new Double_t[fNDetAsy];
  fMCAsyME   = new Double_t[fNDetAsy];
  fMCAsyW    = new Double_t[fNDetAsy];

  fMonSlope = new Double_t*[fNMon];
  UInt_t imon;
  for (imon = 0; imon < fNMon; ++imon)
    {
      fMonSlope[imon] = new Double_t[fNMod];
    }

  fDetSlope = new Double_t*[fNDetAsy];
   UInt_t iasy;
  for (iasy = 0; iasy < fNDetAsy; ++iasy)
    {
      fDetSlope[iasy] = new Double_t[fNMod];
    }

  fDetRCoef  = new Double_t*[fNDetAsy];
  fDetRCoefE  = new Double_t*[fNDetAsy];
  for (iasy = 0; iasy < fNDetAsy; ++iasy)
    {
      fDetRCoef[iasy] = new Double_t[fNDimRegCor];
      fDetRCoefE[iasy] = new Double_t[fNDimRegCor];
    }

  fDetMCoef  = new Double_t*[fNDetAsy];
  fDetMCoefE  = new Double_t*[fNDetAsy];
  for (iasy = 0; iasy < fNDetAsy; ++iasy)
    {
      fDetMCoef[iasy] = new Double_t[fNDimModCor];
      fDetMCoefE[iasy] = new Double_t[fNDimModCor];
    }

  fMonTag    = new TString[fNMon];
  fModTag    = new TString[fNMod];
  fMonType   = new Int_t[fNMon];
  fDifMon    = new Int_t[fNDif];
  fDDifMon0  = new Int_t[fNDDif];
  fDDifMon1  = new Int_t[fNDDif];
  fRegCorMon = new Int_t[fNDimRegCor];
  fModCorMon = new Int_t[fNDimModCor];
  fModCorMod = new Int_t[fNDimModCor];
  fDifExp    = new TString[fNDif];
  fDDifExp   = new TString[fNDDif];
  fAsyTag    = new TString[fNDetAsy];
  fAsyExp    = new TString[fNDetAsy];
  fRegCorExp = new TString[fNDetAsy];
  fModCorExp = new TString[fNDetAsy];

  // Tags for the monitors -- matching the tags used in the analyzer

  fMonTag[0] = "bcm1";
  fMonTag[1] = "bcm2";
  fMonTag[2] = "bpm10x";
  fMonTag[3] = "bpm12x";
  fMonTag[4] = "bpm4ax";
  fMonTag[5] = "bpm4ay";
  fMonTag[6] = "bpm4bx";
  fMonTag[7] = "bpm4by";

  // Types -- 0 for BCMs, 1 for BPMs
  
  fMonType[0] = 0;
  fMonType[1] = 0;
  fMonType[2] = 1;
  fMonType[3] = 1;
  fMonType[4] = 1;
  fMonType[5] = 1;
  fMonType[6] = 1;
  fMonType[7] = 1;

  // Monitors for which we want to see differences

  fDifMon[0] = 0;
  fDifMon[1] = 1;
  fDifMon[2] = 2;
  fDifMon[3] = 3;
  fDifMon[4] = 4;
  fDifMon[5] = 5;
  fDifMon[6] = 6;
  fDifMon[7] = 7;

  // Monitor pairs for which we want to see double differences

  fDDifMon0[0] = 0;  fDDifMon1[0] = 1;
  fDDifMon0[1] = 2;  fDDifMon1[1] = 3;
  fDDifMon0[2] = 4;  fDDifMon1[2] = 6;
  fDDifMon0[3] = 5;  fDDifMon1[3] = 7;

  // Monitors used in regression corrections

  fRegCorMon[0] = 3;
  fRegCorMon[1] = 4;
  fRegCorMon[2] = 5;
  fRegCorMon[3] = 6;
  fRegCorMon[4] = 7;

  // Tags for modulation objects

  fModTag[0] = "MAT1C01H";
  fModTag[1] = "MAT1C02V";
  fModTag[2] = "MAT1C03H";
  fModTag[3] = "MAT1C04H";
  fModTag[4] = "MAT1C05H";
  fModTag[5] = "MAT1C06V";
  fModTag[6] = "MAT1C07V";
  fModTag[7] = "VERNIER";

  // Monitors used in modulation corrections

  fModCorMon[0] = 3;
  fModCorMon[1] = 4;
  fModCorMon[2] = 5;
  fModCorMon[3] = 6;
  fModCorMon[4] = 7;

  // Modulation objects used in modulation corrections

  fModCorMod[0] = 0;
  fModCorMod[1] = 1;
  fModCorMod[2] = 4;
  fModCorMod[3] = 5;
  fModCorMod[4] = 7;

  // Here we build the expressions used to plot monitor differences

  TString xa = "asym_";
  TString xd = "diff_";

  for (UInt_t idif = 0; idif < fNDif; ++idif)
    {
      fDifExp[idif] =
	(fMonType[fDifMon[idif]] == 0 ? xa : xd) + fMonTag[fDifMon[idif]];
    }

  // Expressions for monitor double differences

  for (UInt_t iddif = 0; iddif < fNDDif; ++iddif)
    {
      fDDifExp[iddif] =
	(fMonType[fDDifMon0[iddif]] == 0 ? xa : xd) + 
	fMonTag[fDDifMon0[iddif]] + "-" +
	(fMonType[fDDifMon1[iddif]] == 0 ? xa : xd) + 
	fMonTag[fDDifMon1[iddif]];
    }

  // Tags for raw asymmetries

  fAsyTag[0] = "det1";
  fAsyTag[1] = "det2";
  fAsyTag[2] = "det3";
  fAsyTag[3] = "det4";
//   fAsyTag[4] = "det_l";
//   fAsyTag[5] = "det_r";
//   fAsyTag[6] = "det_hi";
//   fAsyTag[7] = "det_lo";
//   fAsyTag[8] = "det_all";
//   fAsyTag[9] = "det_ave";
  fAsyTag[4] = "det_all";
  fAsyTag[5] = "det_ave";

  // Expressions for raw asymmetries

  xa = "asym_n_";
  for (iasy = 0; iasy < fNDetAsy; ++iasy)
    {
      fAsyExp[iasy] = xa + fAsyTag[iasy];
    }


  // For now, since there are no regression or modulation analyses,
  // set these coefs to zero

  for (iasy = 0; iasy < fNDetAsy; ++iasy)
    for (UInt_t jdim = 0; jdim < fNDimRegCor; ++jdim)
      {
	fDetRCoef[iasy][jdim] = 0.1230;
	fDetRCoefE[iasy][jdim] = 0.01;
      }

  for (iasy = 0; iasy < fNDetAsy; ++iasy)
    for (UInt_t jdim = 0; jdim < fNDimModCor; ++jdim)
      {
	fDetMCoef[iasy][jdim] = 0.3450;
	fDetMCoefE[iasy][jdim] = 0.01;
      }

  // Expressions for regression and modulation corrected asymmetries

  for (iasy = 0; iasy < fNDetAsy; ++iasy)
    {
      fRegCorExp[iasy] = fAsyExp[iasy] + "-(";
      for (UInt_t idim = 0; idim < fNDimRegCor; ++idim)
	{
	  if (idim != 0)
	    fRegCorExp[iasy] += "+";
	  fRegCorExp[iasy] += fDetRCoef[iasy][idim];
	  fRegCorExp[iasy] += "*";
	  fRegCorExp[iasy] +=  fDifExp[fRegCorMon[idim]];
	}
	fRegCorExp[iasy] += ")";
	//	clog << iasy << " " << fRegCorExp[iasy] << endl;

      fModCorExp[iasy] = fAsyExp[iasy] + "-(";
      for (UInt_t idim = 0; idim < fNDimModCor; ++idim)
	{
	  if (idim != 0)
	    fModCorExp[iasy] += "+";
	  fModCorExp[iasy] += fDetMCoef[iasy][idim];
	  fModCorExp[iasy] += "*";
	  fModCorExp[iasy] +=  fDifExp[fModCorMon[idim]];
	}
	fModCorExp[iasy] += ")";
	//	clog << iasy << " " << fModCorExp[iasy] << endl;
    }
}

void
Prompt::~Prompt ()
{
  delete[] fDifM;
  delete[] fDifME;
  delete[] fDifW;
  delete[] fDDifW;
  delete[] fAsyM;
  delete[] fAsyME;
  delete[] fAsyW;
  delete[] fRCAsyM;
  delete[] fRCAsyME;
  delete[] fRCAsyW;
  delete[] fMCAsyM;
  delete[] fMCAsyME;
  delete[] fMCAsyW;

  UInt_t imon;
  for (imon = 0; imon < fNMon; ++imon)
    {
      delete[] fMonSlope[imon];
    }
  delete[] fMonSlope;

  UInt_t iasy;
  for (iasy = 0; iasy < fNDetAsy; ++iasy)
    {
      delete[] fDetSlope[iasy];
    }
  delete[] fDetSlope;

  for (iasy = 0; iasy < fNDetAsy; ++iasy)
    {
      delete[] fDetRCoef[iasy];
      delete[] fDetRCoefE[iasy];
    }
  delete[] fDetRCoef;
  delete[] fDetRCoefE;

  for (iasy = 0; iasy < fNDetAsy; ++iasy)
    {
      delete[] fDetMCoef[iasy];
      delete[] fDetMCoefE[iasy];
    }
  delete[] fDetMCoef;
  delete[] fDetMCoefE;

  delete[] fMonTag;
  delete[] fModTag;
  delete[] fMonType;
  delete[] fDifMon;
  delete[] fDDifMon0;
  delete[] fDDifMon1;
  delete[] fRegCorMon;
  delete[] fModCorMon;
  delete[] fModCorMod;
  delete[] fDifExp;
  delete[] fDDifExp;
  delete[] fAsyTag;
  delete[] fAsyExp;
  delete[] fRegCorExp;
  delete[] fModCorExp;
}

void 
Prompt::Monitors ()
{
  // Plot monitor differences and double differences, and write means,
  // errors, and widths to text file

  TString can_name ("MonitorDiffs");
  TString can_title ("Monitor Differences");
  TCanvas* can_mon1 = frame (fRun, can_name, can_title);
  TPad* pad_mon1 = gPad;

  UInt_t nh = 2;
  UInt_t nv = (fNDif+1)/2;
  UInt_t np = nh * nv;
  pad_mon1->Divide (nh, nv);

  TTree *prtree = (TTree*)gROOT.FindObject("P");
  for (Int_t idif = 0; idif < fNDif; ++idif)
    {
      pad_mon1->cd (idif%np+1);
      prtree->Draw (fDifExp[idif], "ok_cut");

      // NOTE: Provided we're not using an axis sub-range, ROOT's mean
      // and RMS for a histogram created by TTree::Draw come from the
      // *data*, not the histogram (but using only data within
      // histogram limits) -- so should be accurate (provided there
      // are no underflows/overflows).  For our "width" we want the
      // estimated variance, i.e. with sqrt (n-1) in the denominator,
      // rather than RMS with sqrt (n).

      Double_t n = htemp->GetEntries();
      if (n > 1)
	{
	  fDifM[idif] = htemp->GetMean();
	  fDifME[idif] = htemp->GetRMS() / sqrt (n-1);
	  fDifW[idif] = fDifME[idif] * sqrt (n);
	}
      else
	{
	  // This should never happen but if n <= 1, fill in something
	  // ridiculous.
	  fDifM[idif] = 1e99;
	  fDifME[idif] = 1e99;
	  fDifW[idif] = 1e99;
	}
	  

      htemp->Fit ("gaus","Q");
      pad_mon1->Update();
    }
  can_mon1.Print (TaFileName ("output", can_name, "ps").C_str());

  can_name = "MonitorDblDiffs";
  can_title = "Monitor Double Differences";
  TCanvas* can_mon2 = frame (fRun, can_name, can_title);
  TPad* pad_mon2 = gPad;

  nv = (fNDDif+1)/2;
  np = nh * nv;
  pad_mon2->Divide (nh, nv);

  TTree *prtree = (TTree*)gROOT.FindObject("P");
  for (Int_t iddif = 0; iddif < fNDDif; ++iddif)
    {
      pad_mon2->cd (iddif+1);
      prtree->Draw (fDDifExp[iddif], "ok_cut");
      
      Double_t n = htemp->GetEntries();
      if (n > 1)
	{
	  fDDifW[iddif] = htemp->GetRMS() * sqrt (n / (n-1));
	}
      else
	{
	  // This should never happen but if n <= 1, fill in something
	  // ridiculous.
	  fDDifW[iddif] = 1e99;
	}

      htemp->Fit ("gaus", "Q");
      pad_mon2->Update();
    }
  can_mon2.Print (TaFileName ("output", can_name, "ps").C_str());

}

void 
Prompt::Detectors (UInt_t corrected)
{
  // Plot detector distributions -- uncorrected (corrected = 0),
  // regression corrected (corrected = 1), or modulation corrected
  // (corrected = 2) -- and write means, errors, and widths to text
  // file

  TString name0 = (corrected == 0 ? "" 
		   : (corrected == 1 ? "RegCorrected"
		      : "ModCorrected"));
  TString title0 = (corrected == 0 ? "" 
		   : (corrected == 1 ? "Regression Corrected "
		      : "Modulation Corrected "));
  TString can_name (name0 + "DetectorAsyms");
  TString can_title (title0 + "Detector Asymmetries");
  TCanvas* can_det1 = frame (fRun, can_name, can_title);
  TPad* pad_det1 = gPad;

  UInt_t nh = 2;
  UInt_t nv = (fNDetAsy+1)/2;
  UInt_t np = nh * nv;
  pad_det1->Divide (nh, nv);

  Double_t* asym;
  Double_t* asyw;
  Double_t* asyme;
  TString* fexp;

  if (corrected == 0)
    {
      asym = fAsyM;
      asyw = fAsyW;
      asyme = fAsyME;
      fexp = fAsyExp;
    }
  else if (corrected == 1)
    {
      asym = fRCAsyM;
      asyw = fRCAsyW;
      asyme = fRCAsyME;
      fexp = fRegCorExp;
    }
  else
    {
      asym = fMCAsyM;
      asyw = fMCAsyW;
      asyme = fMCAsyME;
      fexp = fModCorExp;
    }

  TTree *prtree = (TTree*)gROOT.FindObject("P");
  for (Int_t iasy = 0; iasy < fNDetAsy; ++iasy)
    {
      pad_det1->cd (iasy%np+1);
      prtree->Draw (fexp[iasy], "ok_cut");
      if (corrected)
	htemp->SetNameTitle ("htemp", title0 + fAsyExp[iasy]);

      Double_t n = htemp->GetEntries();
      if (n > 1)
	{
	  asym[iasy] = htemp->GetMean();
	  asyme[iasy] = htemp->GetRMS() / sqrt (n-1);
	  asyw[iasy] = asyme[iasy] * sqrt (n);
	}
      else
	{
	  // This should never happen but if n <= 1, fill in something
	  // ridiculous.
	  asym[iasy] = 1e99;
	  asyme[iasy] = 1e99;
	  asyw[iasy] = 1e99;
	}

      htemp->Fit ("gaus", "Q");
      pad_det1->Update();
    }
  can_det1.Print (TaFileName ("output", can_name, "ps").C_str());

}

void
Prompt::Print()
{
  // Print prompt analysis results

  TaFileName fn ("output", "macro", "txt");
  ofstream fFile(fn.C_str());
  if (!fFile)
    {
      cerr << "Prompt ERROR: Cannot open output file " << fn.C_str() << endl;
      exit (1);
    }
  else
    clog << "Output file is " << fn.C_str() << endl;

  fFile << "Prompt macro output for run " << fRun << endl;
  fFile << "================================" << endl;

  fFile.setf(ios::left,ios::adjustfield);

  fFile << "\nMonitor differences (asymmetries):" << endl;
  Int_t idif;
  for (idif = 0; idif < fNDif; ++idif)
    {
      fFile << setw(8) << fMonTag[fDifMon[idif]]
	    << " Mean " 
	    << setw(8) << fDifM[idif]
	    << " +- " << setw(8) << fDifME[idif]
	    << "  Width " 
	    << setw(8) << fDifW[idif]
	    << endl;
    }

  fFile << "\nMonitor double differences:" << endl;
  for (Int_t iddif = 0; iddif < fNDDif; ++iddif)
    {
      fFile << setw(8) << fMonTag[fDDifMon0[iddif]]
	    << " - " << setw(8) << fMonTag[fDDifMon1[iddif]]
	    << "  Width " 
	    << setw(8) << fDDifW[iddif]
	    << endl;
    }


  fFile << "\nDetector Asymmetries:" << endl;
  UInt_t idim;
  for (Int_t iasy = 0; iasy < fNDetAsy; ++iasy)
    {
      fFile << setw(8) << fAsyTag[iasy]
	    << " Raw " 
	    << " Mean " 
	    << setw(8) << fAsyM[iasy]
	    << " +- " << setw(8) << fAsyME[iasy]
	    << "  Width " 
	    << "   " << setw(8) << fAsyW[iasy] << endl;
      fFile << "        "
	    << " Reg " 
	    << " Mean " 
	    << setw(8) << fRCAsyM[iasy]
	    << " +- " << setw(8) << fRCAsyME[iasy]
	    << "  Width " 
	    << "   " << setw(8) << fRCAsyW[iasy] << endl;
      for (idim = 0; idim < fNDimRegCor; ++idim)
	{
	  UInt_t jdif = fRegCorMon[idim];
	  fFile << "             " << setw(8) << fMonTag[jdif]
		<< " " << setw(8) << fDetRCoef[iasy][idim]
		<< " +- " << setw(8) << fDetRCoefE[iasy][idim]
		<< " " << setw(8) << fabs (fDetRCoef[iasy][idim]) * fDifW[jdif]
		<< " " << setw(8) << fDetRCoef[iasy][idim] * fDifM[jdif]
		<< endl;
	}
      fFile << "        "
	    << " Mod " 
	    << " Mean " 
	    << setw(8) << fMCAsyM[iasy]
	    << " +- " << setw(8) << fMCAsyME[iasy]
	    << "  Width " 
	    << "   " << setw(8) << fMCAsyW[iasy]
	    << endl;
      for (idim = 0; idim < fNDimModCor; ++idim)
	{
	  UInt_t jdif = fModCorMon[idim];
	  fFile << "             " << setw(8) << fMonTag[jdif]
		<< " " << setw(8) << fDetMCoef[iasy][idim]
		<< " +- " << setw(8) << fDetMCoefE[iasy][idim]
		<< " " << setw(8) << fabs (fDetMCoef[iasy][idim]) * fDifW[jdif]
		<< " " << setw(8) << fDetMCoef[iasy][idim] * fDifM[jdif]
		<< endl;
	}
    }

  fFile.close();
}

void 
style ()
{
    gStyle->SetOptStat (1110);
    gStyle->SetOptFit (0111);
    gStyle->SetStatH (0.15);
    gStyle->SetStatW (0.20);
    gStyle->SetTitleH (0.08);
    gStyle->SetTitleW (0.6);
    gStyle->SetLabelSize (0.05, "x");
    gStyle->SetLabelSize (0.05, "y");
    //    gStyle->SetPaperSize(TStyle::kUSLetter);
    gStyle->SetPaperSize(20,24);
    gROOT->ForceStyle();
}

void 
prompt (Int_t run)
{
  gROOT->Reset();
  gROOT->LoadMacro ("frame.macro");

  if (run <= 0)
    {
      cout << "Enter run number : ";
      cin >> run;
    }
  clog << "Run " << run << endl;
  TaFileName::Setup (run, "prompt");

  Prompt pr(run);

  TaFileName fn ("root");
  TString file = fn.C_str();

  clog << "ROOT file is " << file << endl;
  f = new TFile(file);
  //  TTree *evtree = (TTree*)gROOT.FindObject("R");

  style ();

  pr.Monitors ();
  pr.Detectors (0);
  pr.Detectors (1);
  pr.Detectors (2);
  pr.Print ();

}
